<h1 style="text-align:center">离散对数求解 实验报告</h1>

<h4 style="text-align:center">学号：SA20225172  姓名：郭俊勇</h4>

## 实现目的

- 掌握与密码学相关的基础数论知识； 
- 利用中间相遇攻击来编程实现离散对数的求解。

## 编程语言

- Python

## 实现内容

![image-20210409083302297](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210409083302297.png)

## 实验原理分析

- 利用中间相遇的方式减小运算的时间复杂度。

- 基础版：按照实验要求设置x=x0*B+x1构造。

- 改进版：将x=x0\*B+x1改变成x=x0*B-x1,这样可以节省计算1/g^x1的时间，大大提高算法的运行时间。在本质上两个表达式无差别。


## Python代码实现（源码）

### 基础版

```python
import gmpy2
import time

# 初始参数
p = 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084171
g = 11717829880366207009516117596335367088558084999998952205599979459063929499736583746670572176471460312928594829675428279466566527115212748467589894601965568
h = 3239475104050450443565264378728065788649097520952449527834792452971981976143292558073856937958553180532878928001494706097394108577585732452307673444020333
B = 2 ** 20  # 1048576

# 创建空字典
hashmap = {}

# 记录开始的时间
start = time.process_time()

# 处理下x1
# h mod p
m0 = gmpy2.f_mod(h, p)
for x1 in range(B):
    # g^x1 mod p
    m1 = gmpy2.powmod(g, x1, p)
    # 1/g^x1
    m2 = gmpy2.invert(m1, p)
    # h*1/g^x1 mod p
    m3 = gmpy2.f_mod(m0 * m2, p)
    # 记录x1 和 h*1/g^x1 mod p
    hashmap[m3] = x1

# g^B mod p
right = gmpy2.powmod(g, B, p)

for x0 in range(B):
    # g^B^x0 mod p
    c = gmpy2.powmod(right, x0, p)
    # 判断是否在右边的hashmap中
    if c in hashmap:
        # x = x0*B - x1
        x = gmpy2.mul(B, x0) - hashmap[c]
        print("x0=", x0)
        print("x1=", hashmap[c])
        print("x= ", x)
        break
# 记录结束时间
end = time.process_time()
print("The running time totals is", end - start, "s")
```

### 改进版

```python
import gmpy2
import time

# 初始参数
p = 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084171
g = 11717829880366207009516117596335367088558084999998952205599979459063929499736583746670572176471460312928594829675428279466566527115212748467589894601965568
h = 3239475104050450443565264378728065788649097520952449527834792452971981976143292558073856937958553180532878928001494706097394108577585732452307673444020333
B = 2 ** 20  # 1048576

# 创建空字典
hashMap = {}

# 优化后，令x=Bx0-x1
start = time.process_time()
s0 = gmpy2.f_mod(h, p)
for x1 in range(1048577):
    # g^x1 mod p
    s1 = gmpy2.powmod(g, x1, p)
    # h*g^x1 mod p
    s2 = gmpy2.f_mod(s1 * s0, p)
    hashMap[s2] = x1  

r = gmpy2.powmod(g, B, p)
for x0 in range(len(hashMap)):
    c = gmpy2.powmod(r, x0, p)
    if c in hashMap:
        x = gmpy2.mul(B, x0) - hashMap[c]
        print("x0=", x0)
        print("x1=", hashMap[c])
        print("x=", x)
        break
end = time.process_time()
print("The running time totals is", end - start, "s")
```

## 运行结果

### 基础版

![image-20210409083734338](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210409083734338.png)

### 改进版

![image-20210409083950386](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210409083950386.png)