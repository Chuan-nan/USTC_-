# 密码学

## 第一章 计算机与网络安全概念

密码算法与协议主要领域：对称加密、非对称加密、数据完整性算法、认证协议

### 1.1 计算机安全的概念

#### 1.1.1 计算机的安全定义

计算机安全最核心的三个关键目标（CIA三元组）：

- 保密性（confidentiality）——数据保密性、隐私性
- 完整性（Integrity）——数据完整性、系统完整性
- 可用性（Availability）

> tips:额外两个特性——真实性（Authenticity）、可追溯性（Accountability）

### 1.2 OSI安全架构

X.800即OSI安全框架，它提供安全的一种组织方法。OSI安全架构主要关注安全攻击、安全机制和安全服务。

- 安全攻击   任何危及信息系统安全的行为。
- 安全机制   用来检测、阻止攻击或从攻击状态恢复到正常状态的过程（或实现该过程的设备)。
- 安全服务   加强数据处理系统和信息传输的安全性的一种处理过程或通信服务，目的在于利用一      种或多种安全机制进行反攻击。

### 1.3 安全攻击

攻击划分：主动攻击、被动攻击

#### 1.3.1 被动攻击

特点：对传输进行窃听和检测。不涉及对数据的修改。

攻击方式：信息泄露、流量分析

防御方式：预防为主

#### 1.3.2 主动攻击

特点：对数据流进行修改或伪造数据流

攻击方式：伪装、重放、消息修改和拒绝服务

防御方式：检测为主

### 1.4 安全服务

X.800将安全服务定义为:在通信开放系统中，为系统或数据传输提供足够安全的协议层服务。RFC 4949中给出的定义可能更清晰:安全服务是一种由系统提供的对系统资源进行特殊保护的处理或通信服务;安全服务通过安全机制来实现安全策略。

![image-20210413134909502](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413134909502.png)

### 1.5 安全机制

分类：一类在特定的协议层实现，如TCP或应用层协议；另一类不属于任何协议层或安全服务。

![image-20210413135150831](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413135150831.png)

安全服务与机制间的联系

![image-20210413135240703](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413135240703.png)

### 1.8 网络安全模型

![image-20210413135559040](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413135559040.png)

上述模型说明，设计安全服务应包含如下4个方面的内容:

1. 设计一个算法,它执行与安全相关的变换。该算法应是攻击者无法攻破的。
2. 产生算法所使用的秘密信息。
3. 设计分配和共享秘密信息的方法。
4. 指明通信双方使用的协议，该协议利用安全算法和秘密信息实现安全服务。

## 第三章 传统加密技术

### 3.1 对称密码模型

对称加密的五个基本成分

明文、密文、密钥、加密算法、解密算法

传统密码的简化模型

![image-20210328154547858](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210328154547858.png)传统密码学安全的前提

强大的加密算法（Kerckhoffs' principle：默认算法是公开的）

密钥只有发送方和接收方知道

#### 3.1.1 密码编码学

密码学系统具备的三个独立特征

（1）转换明文为密文的运算类型

​          代替：代替是将明文中的每个元素映射成另一个元素

​          置换：置换是将明文中的元素重新排列

​          乘积：多层代替和置换

（2）所用的密钥数

​          对称密钥、单密钥、秘密密钥、传统密钥

​          非对称密钥、双钥、公钥密码

（3）处理明文的方法

​          分组密码：每次处理输入的一组元素，相应的输出一组元素

​          流密码：连续地处理输入元素，每次输出一个元素

#### 3.1.2密码分析学和穷举攻击

攻击密码系统的典型目标是恢复使用的密钥而不是仅仅恢复出单个密文对应的明文。攻击传统的密码体制有两种通用的方法:

- 密码分析学：密码分析学攻击依赖于算法的性质、明文的一般特征或某些明密文对。这种形式的攻击企图利用算法的特征来推导出特定的明文或使用的密钥。

- 穷举攻击：攻击者对一条密文尝试所有可能的密钥直到把它转化为可读的有意义的明文。平均而言，获得成功至少要尝试所有可能密钥的一半。

对加密信息地攻击类型

![image-20210328161410962](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210328161410962.png)

无条件安全

无论有多少可使用的密文，都不足以唯一地确定密文所对应的明文，则称该加密体制是无条件安全的。也就是说无论花多少时间，攻击者都无法将密文解密，这仅仅因为他(或她）所需的信息不在密文里。除了一次一密（在以后的章节中将会讲到)之外，所有的加密算法都不是无条件安全的。

加密算法地挑选标准

破译密码的代价超出密文信息的价值。

破译密码的时间超出密文信息的有效生命期。

### 3.2 代替技术（Substitution）

#### 3.2.1 Caesar密码

Caesar密码：每个字母用它之后的第三个字母代替
$$
C=E(3,p)=(p+3)mod(26)
$$
一般通式：
$$
C=E(k,p)=(p+k)mod(26)
$$
Caesar密码的三个重要特征使我们可以采用穷举攻击分析方法。
(1）已知加密和解密算法。

(2）需测试的密钥只有25个。

(3）明文所用的语言是已知的，且其意义易于识别。

#### 3.2.2 单表代替密码

Caesar密码的加强版，密文行是26个字母的任意置换，那么就有26！或大于4*10^26种可能的密钥。这种方法被称为单表替换。

单表代替密码比较容易被攻破，因为它带有原始字母使用频率的一些统计特征。一种对策是对每个字母提供多种代替，称为同音词，一个明文单元也可以变成不同的密文单元。

有两种主要的方法可以减少代替密码里明文结构在密文中的残留度:

:one:对明文中的多个字母一起加密;

:two:另一种是采用多表代替密码。

#### 3.2.5 多表代替加密

对简单单表代替的改进方法是在明文消息中采取不同的单表代替。

Vigenere密码

多表代替密码中最著名的和最简单的是Vigenere密码。它的代替规则集由26个Caesar密码的代替表组成，其中每一个代替表是对明文字母表移位0~25次后得到的代替单表。每个密码由一个密钥字母来表示，这个密钥字母用来代替明文字母a，故移位3次的Caesar密码由密钥值d来代表。

加密方程：

![image-20210413155013508](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413155013508.png)

例子：

![image-20210413155209874](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413155209874.png)

Vernam密码 

![image-20210413155454748](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413155454748.png)

足够的密文，使用已知或可能的明文序列，或者二者联合使用，该方案可以被破解。

#### 3.2.6 一次一密

对Vernam密码的改进，使用与消息一样长且无重复的随机密钥来加密信息，另外，密钥只对一个消息进行加解密，之后丢弃不用。

一次一密的安全性完全取决于密钥的随机性。

一次一密的难点：

1. 产生大规模随机密钥有实际困难。任何经常使用的系统都需要建立在某个规则基础上的百万个随机字符，提供这样规模的真正随机字符是相当艰巨的任务。
2. 更令人担忧的是密钥的分配和保护。对每一条发送的消息，需要提供给发送方和接收方等长度的密钥。因此，存在庞大的密钥分配问题。

### 3.3 置换技术

![image-20210413160334133](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413160334133.png)

### 3.4 转轮机

![image-20210413160456049](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210413160456049.png)

### 3.5 隐写术

## 第四章 分组密码和数据加密标准

4.1 传统分组密码结构

Feistel分组密码结构

4.1.1 流密码与分组密码

流密码：每次加密数据流的一位或一个字节。

![image-20210414204053912](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210414204053912.png)

分组密码：将一个明文分组作为整体加密并且通常得到的是与明文等长的密文分组。（典型的分组的大小是64位或者128位）

![image-20210414204255717](C:\Users\Brian\AppData\Roaming\Typora\typora-user-images\image-20210414204255717.png)

4.1.2 Feistel密码结构的设计动机

Feistel称这种密码为理想分组密码，因为它允许生成最大数量的加密映射来映射明文分组。

理想分组密码现实很难实现！！

分组规模太小，等价于传统的代替密码，利用统计分析法可以轻易攻破。

若分组有抗统计攻击的理想长度，其密钥大小将要64×24=2^70  大约为10^21位。不现实！！！
Feistel是对理想分组的一种近似体制。

4.1.3 Feistel密码

Feistel建议使用乘积密码的概念来逼近理想分组密码。乘积密码是指依次使用两个或两个以上基本密码,所得结果的密码强度将强于所有单个密码的强度。这种方法的本质是开发一个分组密码,密钥长为k位，分组长为n位，采用2^k个变换，而不是理想分组密码的2^n!个可用变换。
特别地，Feistel建议使用这样的密码:该种密码交替地使用代替和置换。代替和置换的定义如下:

- 代替   每个明文元素或元素组被唯一地替换为相应的密文元素或元素组。
- 置换   明文元素的序列被替换为该序列的一个置换。也就是说，序列里没有元素被添加，删除或替换，但序列里元素出现的顺序改变了。

d